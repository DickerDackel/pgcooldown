#define DOCSTRING_MODULE "Cooldown & co...\n\nThis module started with just the Cooldown class, which can be used check if a\nspecified time has passed.  It is mostly indended to be used to control\nobjects in a game loop, but it is general enough for other purposes as well.\n\n    fire_cooldown = Cooldown(1, cold=True)\n    while True:\n        if fire_shot and fire_cooldown.cold():\n            fire_cooldown.reset()\n            launch_bullet()\n\n        ...\n\nWith the usage of Cooldown on ramp data (e.g. a Lerp between an opaque and a\nfully transparent sprite over the time of n seconds), I came up with the\nLerpThing.  The LerpThing gives you exactly that.  A lerp between `from` and\n`to` mapped onto a `duration`.\n\n    alpha = LerpThing(0, 255, 5)\n    while True:\n        ...\n        sprite.set_alpha(alpha())\n        # or sprite.set_alpha(alpha.v)\n\n        if alpha.finished:\n            sprite.kill()\n\nSince LerpThing obviously needs lerp functions internally, the 3 convenience\nfunctions `lerp`, `invlerp`, and `remap` are provided.\n\nFinally, the need to use Cooldown for scheduling the creations of game\nobjects, the CronD class was added.  It schedules functions to run after a\nwait period.\n\nNote, that CronD doesn't do any magic background timer stuff, it needs to be\nupdated in the game loop.\n\n    crond = CronD()\n    crond.add(1, lambda: create_enemy(screen.center))\n    crond.add(2, lambda: create_enemy(screen.center))\n    crond.add(3, lambda: create_enemy(screen.center))\n    crond.add(4, lambda: create_enemy(screen.center))\n\n    while True:\n        ...\n        crond.update()\n"
#define DOCSTRING_LERP "lerp, invlerp and remap\nExported for convenience, since these are internally used in the LerpThing.\n\nThese are your normal lerp functions.\n\n    lerp(a: float, b:float, t) -> float\n        Returns interpolation from a to b at point in time t\n\n    invlerp(a: float, b: float, v: float) -> float\n        Returns t for interpolation from a to b at point v.\n\n    remap(a0: float, b0: float, a1: float, b1: float, v0: float) -> float\n        Maps point v0 in range a0/b0 onto range a1/b1.\n\nExample function or class method with PEP 484 type annotations.\nwith the NumPy docstring style.\n\nNote: Don't include the  parameter.\n\nParameters\n----------\nparam1\n    The first parameter.\nparam2\n    The second parameter.\n\nReturns\n-------\nbool\n    True if successful, False otherwise.\n\nRaises\n------\nException\n    True if successful, False otherwise.\n"
#define DOCSTRING_COOLDOWN "A cooldown/counter class to wait for stuff in games.\n\n    cooldown = Cooldown(5)\n\n    while True:\n        do_stuff()\n\n        if key_pressed\n            if key == 'P':\n                cooldown.pause()\n            elif key == 'ESC':\n                cooldown.start()\n\n        if cooldown.cold():\n            launch_stuff()\n            cooldown.reset()\n\nThis can be used to time sprite animation frame changes, weapon\ncooldown in shmups, all sorts of events when programming a game.\n\nIf you want to use the cooldown more as a timing gauge, e.g. to modify\nacceleration of a sprite over time, have a look at the `LerpThing`\nclass below, which makes this incredibly easy.\n\nOnce instantiated, it saves the current time as t0.  On every check,\nit compares the then current time with t0 and returns as 'cold' if the\ncooldown time has passed.\n\nThe cooldown can be paused, in which case it saves the time left.  On\nrestart, it'll set again t0 to the remaining time and continues to\ncompare as normal against the left cooldown time.\n\nAt any time, the cooldown can be reset to its initial or a new value.\n\nA cooldown can be compared to int/float/bool, in which case the\n`remaining` property is used.\n\nCooldown provides a \"copy constructor\", meaning you can initialize a\nnew cooldown with an existing one.  The full state of the initial\ncooldown is used, including `paused`, `wrap`, and the remaining time.\n\nDepending on the wrap setting, when reset, the cooldown is either\nreset to the initial duration, or the time that has passed since the\ncooldown ended is substracted.  E.g.\n\n    c = Cooldown(1, wrap=True)\n    sleep(1.5)\n    c.reset()\n\n        --> c.remaining is now 0.5, not 1\n\nCooldown instances can be used as an iterator, returning the time\nremaining.\n\n\nArguments\n---------\nduration: float | pgcooldown.Cooldown\n    Time to cooldown in seconds\n\ncold: bool = False\n    Start the cooldown already cold, e.g. for initial events.\n\npaused: bool = False\n    Created the cooldown in paused state.  Use `cooldown.start()` to\n    run it.\n\nwrap: bool = False\n    Set the reset mode to wrapped (see above).\n\n\nAttributes\n----------\nAll attributes are read/write.\n\nduration: float\n    When calling `reset`, the cooldown is set to this value. Can be\n    assigned to directly or by calling `cooldown.reset(duration)`\n\ntemperature: float\n    The time left (or passed) until cooldown.  Will go negative once\n    the cooldown time has passed.\n\nremaining: float\n    Same as temperature, but will not go below 0.  When assigning, a\n    negative value will be reset to 0.\n\nnormalized: float\n    returns the current \"distance\" in the cooldown between 0 and 1,\n    with one being cold.\n\npaused: bool\n    to check if the cooldown is paused.  Alternatively use\n    cooldown.pause()/.start()/.is_paused() if you prefer methods.\n\nwrap: bool\n    Activate or deactivate wrap mode.\n\n\nMethods\n-------\nCooldown provides a __repr__, the comparism methods <, <=, ==, >=, >\nand can be converted to float, int, and bool.  The 'temperature' value\nis used for this, so results can be negative.\n\ncold(): bool\n    Has the time of the cooldown run out?\n\nhot(): bool\n    Is there stil time remaining before cooldown?  This is just for\n    convenience to not write `cooldown not cold` all over the place.\n\nreset([new-duration]):\n    Resets the cooldown.  Without argument, resets to the current\n    duration, otherwise the given value.  See wrap for nuance.\n\npause(), start(), is_paused():\n    Pause, start, check the cooldown.  Time is frozen during the\n    pause.\n\nset_to(val):\n    Deprecated, assign to cooldown.duration instead.\n\nset_cold():\n    Deprecated, assign to cooldown.duration instead.\n"
#define DOCSTRING_COOLDOWN_RESET "reset the cooldown, optionally pass a new temperature.\n\nTo reuse the cooldown, it can be reset at any time, optionally with a\nnew duration.\n\nreset() also clears pause.\n\nParameters\n----------\nnew: float = 0\n    If not 0, set a new timeout value for the cooldown\n\nwrap: bool = False\n    If `wrap` is `True` and the cooldown is cold, take the time\n    overflown into account:\n\n    e.g. the temperature of a Cooldown(10) after 12 seconds is `-2`.\n\n        `cooldown.reset()` will set it back to 10.\n        `cooldown.reset(wrap=True)` will set it to 8.\n\n    Use `wrap=False` if you need a constant cooldown time.\n    Use `wrap=True` if you have a global heartbeat.\n\n    If the cooldown is still hot, `wrap` is ignored.\n\nReturns\n-------\nself\n    Can be e.g. chained with `pause()`\n"
#define DOCSTRING_COOLDOWN_COLD "Current state of the cooldown.\n\nThe cooldown is cold, if all its time has passed.  From here, you can\neither act on it and/or reset.\n\nReturns\n-------\nbool\n    True if cold\n\nNote\n----\nSince v0.2.8, this is no longer a property but a function.\n"
#define DOCSTRING_COOLDOWN_HOT "Counterpart to cold() if you prefere this more."
#define DOCSTRING_COOLDOWN_PAUSE "Pause, start, check status of the cooldown.\n\n    cooldown.pause()\n    if cooldown.is_paused():\n        ...\n    cooldown.start()\n\nReturns\n-------\nself\n    For chaining.\n"
#define DOCSTRING_COOLDOWN_DURATION "duration: float\n    When calling `reset`, the cooldown is set to this value. Can be\n    assigned to directly or by calling `cooldown.reset(duration)`"
#define DOCSTRING_COOLDOWN_WRAP "wrap: bool\n    Activate or deactivate wrap mode."
#define DOCSTRING_COOLDOWN_PAUSED "paused: bool\n    to check if the cooldown is paused.  Alternatively use\n    cooldown.pause()/.start()/.is_paused() if you prefer methods."
#define DOCSTRING_COOLDOWN_TEMPERATURE "temperature: float\n    The time left (or passed) until cooldown.  Will go negative once\n    the cooldown time has passed."
#define DOCSTRING_COOLDOWN_REMAINING "remaining: float\n    Same as temperature, but will not go below 0.  When assigning, a\n    negative value will be reset to 0."
#define DOCSTRING_COOLDOWN_NORMALIZED "normalized: float\n    returns the current \"distance\" in the cooldown between 0 and 1,\n    with one being cold."
